---
toc: false
badges: false
comments: false
description: Learning is hard...
categories: [advent-of-code, stream-of-consciousness]
title: What I Want From The Advent of Code
---

I learned about Advent of Code (AoC) for the first time back when I was first
learning to program. I'm a self-taught guy, insofar as such a thing exists, and
it seemed like a neat thing. The trouble is, the problems are hard! I was
nowhere near ready to tackle them back then.

Fast-forward to now. I'm actually a working developer, with several years of
experience on the job! I worked for years to learn, and built up the ability to
be gainfully employed in the field of web-development. It seemed to me like I
should be a little more prepared to take a whack at the AoC challenges!

Nope. Not at all.

I believe that there are two kinds of knowledge:
1. The things that you know because you have "learned" them
2. The things that you know because you have experienced them

In an ideal world, schooling would include both. But once you get out into the
world, sometimes you don't have time for one or the other. I put "learned" in
quotes because there's not a word that comes to mind for what I'm trying to
say.  In this case I guess I mean something like, "You have studied it
theoretically. Perhaps read about it, and you have done so sufficiently to
produce a lasting awareness." I think that in most cases people mean "learn" to
be both steps. Except when they don't. Language is, after all, a somewhat messy
set of abstractions.

But I digress. Early on in the process of interviewing I read a lot of posts in
various media about the disconnect between these types of problems and what you
actually deal with on the job. My current experience with AoC is me taking the
second step.

I very rarely need to be concerned with what algorithm there is for traversing
a graph efficiently. More often than not that sort of thing is either
implemented already, or is outside of the scope of my domain. Keeping in mind
that I work in web-development as a full-stack engineer, what I usually have to
deal with is more banal. I am much more likely to have to pick a dependency
than a sorting algorithm.

But there's another side of that which I also read about: you don't need to
know it until you do, and if you don't, then your solution is going to be
garbage.

This is going to be a lot of the same for anyone who spends a lot of time
reading technical blogs. Also, is anyone actually reading this? I dunno. But
sometimes you _do_ run across hard problems. Sometimes, whether through some
contraint of the work environment (that dependency's license isn't allowed) or
the logic required (we need it to be _almost_ that but this edge case in the
business logic breaks the dependency), you can't use an existing solution.
That's when knowing, and I mean _really_ knowing these problems and their
solutions will shine.

You might be able to see through a tree traversal problem that is hiding under
the hood of an HTML rendering issue. Or perhaps you'll see the topological sort
in an attempt to organize various YAML files. Because it's so niche, and so
much a part of the application's nuance, there is no solution besides what you
can build.

When I started to try and do a post for each day of the AoC this year, I
thought I could keep up; and I did for a little while. But then I hit a problem
that I truly didn't know how to solve. Then I hit a problem that I knew how to
solve, but only in the naive way. Then I hit another, and another, and another
that I just. couldn't. solve.

So, while my original goal is not achievable, I want to keep going. I think
that there is value in pushing yourself to learn these things. But more than
that, I think that there is value in learning to fail, and push forward with
altered expectations. That's what I want to get  from AoC this year. The
feeling of succeeding after failure.
